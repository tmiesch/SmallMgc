/******************************************************************************
 * SmallMGC
 *
 * Copyright (C) 2009 Thomas Miesch
 *
 * Authors: Thomas Miesch <thomas.miesch@smallmgc.org>
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * created:
 * filename:
 * purpose:
 *
 ******************************************************************************/
#include <sys/un.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/types.h>

#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include "smallmgcapi.h"

SmallMGC_Api::SmallMGC_Api()
{
  // TODO Auto-generated constructor stub
  createUnixSockets();

}

SmallMGC_Api::~SmallMGC_Api()
{
  // TODO Auto-generated destructor stub
}

int SmallMGC_Api::addGateway(SmallMGC_Api_Gateway* gateway)
{
  char buffer[2000];
  SmallMGC_Api_Commands* command = (SmallMGC_Api_Commands*)buffer;
  *command = SmallMGC_API_COMMAND_CONFIG_ADD_GATEWAY;
  int size = sizeof(SmallMGC_Api_Gateway);
  memcpy(buffer+4, (char*)gateway, size);
  sendOverSockets(buffer, sizeof(SmallMGC_Api_Gateway)+4);
  return 0;
}

int SmallMGC_Api::removeGateway(SmallMGC_Api_Gateway* gateway)
{
  char buffer[2000];
  SmallMGC_Api_Commands* command = (SmallMGC_Api_Commands*)buffer;
  *command = SmallMGC_API_COMMAND_CONFIG_REMOVE_GATEWAY;
  memcpy(buffer+4, (char*)gateway, sizeof(gateway));
  sendOverSockets(buffer, sizeof(buffer));
  return 0;
}

int SmallMGC_Api::blockGateway(SmallMGC_Api_Gateway* gateway)
{
  char buffer[2000];
  SmallMGC_Api_Commands* command = (SmallMGC_Api_Commands*)buffer;
  *command = SmallMGC_API_COMMAND_CONFIG_BLOCK_GATEWAY;
  memcpy(buffer+4, (char*)gateway, sizeof(gateway));
  sendOverSockets(buffer, sizeof(buffer));
  return 0;
}


int SmallMGC_Api::addSubscriber(SmallMGC_Api_Subscriber* subscriber)
{
  char buffer[2000];
  SmallMGC_Api_Commands* command = (SmallMGC_Api_Commands*)buffer;
  *command = SmallMGC_API_COMMAND_CONFIG_ADD_SUBSCRIBER;
  memcpy(buffer+4, (char*)subscriber, sizeof(subscriber));
  sendOverSockets(buffer, sizeof(buffer));
  return 0;
}

int SmallMGC_Api::removeSubscriber(SmallMGC_Api_Subscriber* subscriber)
{
  char buffer[2000];
  SmallMGC_Api_Commands* command = (SmallMGC_Api_Commands*)buffer;
  *command = SmallMGC_API_COMMAND_CONFIG_REMOVE_SUBSCRIBER;
  memcpy(buffer+4, (char*)subscriber, sizeof(subscriber));
  sendOverSockets(buffer, sizeof(buffer));
  return 0;
}

int SmallMGC_Api::blockSubscriber(SmallMGC_Api_Subscriber* subscriber)
{
  char buffer[2000];
  SmallMGC_Api_Commands* command = (SmallMGC_Api_Commands*)buffer;
  *command = SmallMGC_API_COMMAND_STATUS_SUBSCRIBER_OUTSERVICE_FORCED;
  memcpy(buffer+4, (char*)subscriber, sizeof(subscriber));
  sendOverSockets(buffer, sizeof(buffer));
  return 0;
}
int SmallMGC_Api::unblockSubscriber(SmallMGC_Api_Subscriber* subscriber)
{
  char buffer[2000];
  SmallMGC_Api_Commands* command = (SmallMGC_Api_Commands*)buffer;
  *command = SmallMGC_API_COMMAND_STATUS_SUBSCRIBER_INSERVICE;
  memcpy(buffer+4, (char*)subscriber, sizeof(subscriber));
  sendOverSockets(buffer, sizeof(buffer));
  return 0;
}
int SmallMGC_Api::shutdownSubscriber(SmallMGC_Api_Subscriber* subscriber)
{
  char buffer[2000];
  SmallMGC_Api_Commands* command = (SmallMGC_Api_Commands*)buffer;
  *command = SmallMGC_API_COMMAND_STATUS_SUBSCRIBER_OUTSERVICE;
  memcpy(buffer+4, (char*)subscriber, sizeof(subscriber));
  sendOverSockets(buffer, sizeof(buffer));
  return 0;
}
SmallMGC_Api_SubscriberStatus*  SmallMGC_Api::getSubscriberStatus(SmallMGC_Api_Subscriber* subscriber)
{

	return 0;
}
int SmallMGC_Api::setSubscriberStatus(SmallMGC_Api_SubscriberStatus* status)
{

	return 0;
}
int SmallMGC_Api::setGatewayStatus(SmallMGC_Api_GatewayStatus* status)
{

	return 0;
}
SmallMGC_Api_GatewayStatus*  SmallMGC_Api::getGatewayStatus(SmallMGC_Api_Gateway* subscriber)
{

	return 0;
}

int SmallMGC_Api::subscriberAlarmSet(SmallMGC_Api_SubscriberAlarms* subscriberAlarms)
{

	return 0;
}
int SmallMGC_Api::subscriberAlarmClear(SmallMGC_Api_SubscriberAlarms* subscriberAlarms)
{

	return 0;
}

int SmallMGC_Api::gatewayAlarmSet(SmallMGC_Api_GatewayAlarms* gatewayAlarms)
{

	return 0;
}
int SmallMGC_Api::gatewayAlarmClear(SmallMGC_Api_GatewayAlarms* gatewayAlarms)
{

	return 0;
}


int SmallMGC_Api::setConfigSA(SmallMGC_Api_ConfigSA* configSA)
{
  char buffer[2000];
  SmallMGC_Api_Commands* command = (SmallMGC_Api_Commands*)buffer;
  *command = SmallMGC_API_COMMAND_CONFIG_SMALLMGC_SA;
  memcpy(buffer+4, (char*)configSA, sizeof(configSA));
  sendOverSockets(buffer, sizeof(buffer));
  return 0;
}

int SmallMGC_Api::setConfigDigitmap(SmallMGC_Api_ConfigDigitmap* configDigitmap)
{
  char buffer[2000];
  SmallMGC_Api_Commands* command = (SmallMGC_Api_Commands*)buffer;
  *command = SmallMGC_API_COMMAND_CONFIG_SMALLMGC_DIGITMAP;
  memcpy(buffer+4, (char*)configDigitmap, sizeof(configDigitmap));
  sendOverSockets(buffer, sizeof(buffer));
  return 0;
}

int SmallMGC_Api::setConfigGeneral(SmallMGC_Api_ConfigGeneral* configGeneral)
{
  char buffer[2000];
  SmallMGC_Api_Commands* command = (SmallMGC_Api_Commands*)buffer;
  *command = SmallMGC_API_COMMAND_CONFIG_SMALLMGC_GENERAL;
  memcpy(buffer+4, (char*)configGeneral, sizeof(configGeneral));
  sendOverSockets(buffer, sizeof(buffer));
  return 0;
}

int SmallMGC_Api::setConfigIp(SmallMGC_Api_ConfigIp* config)
{
  char buffer[2000];
  SmallMGC_Api_Commands* command = (SmallMGC_Api_Commands*)buffer;
  *command = SmallMGC_API_COMMAND_CONFIG_SMALLMGC_IP;
  memcpy(buffer+4, (char*)config, sizeof(config));
  sendOverSockets(buffer, sizeof(buffer));
  return 0;

}

SmallMGC_Api_ConfigSA* SmallMGC_Api::getConfigSA()
{

	return 0;
}

SmallMGC_Api_ConfigDigitmap* SmallMGC_Api::getConfigDigitmap()
{

  return 0;
}

SmallMGC_Api_ConfigGeneral* SmallMGC_Api::getConfigGeneral()
{

  return 0;
}

SmallMGC_Api_ConfigIp* SmallMGC_Api::getConfigIp()
{

	return 0;
}

int SmallMGC_Api::startTest(char* filePath)
{
  char buffer[2000];
  SmallMGC_Api_Commands* command = (SmallMGC_Api_Commands*)buffer;
  *command = SmallMGC_API_TEST_START;
  memcpy(buffer+4, (char*)filePath, strlen(filePath));
  sendOverSockets(buffer, sizeof(buffer));
  return 0;
}

int SmallMGC_Api::stopTest(char* filePath)
{
  char buffer[2000];
  SmallMGC_Api_Commands* command = (SmallMGC_Api_Commands*)buffer;
  *command = SmallMGC_API_TEST_STOP;
  memcpy(buffer+4, (char*)filePath, strlen(filePath));
  sendOverSockets(buffer, sizeof(buffer));
  return 0;
}

int SmallMGC_Api::getTestResult()
{
  char buffer[2000];
  SmallMGC_Api_Commands* command = (SmallMGC_Api_Commands*)buffer;
  *command = SmallMGC_API_TEST_RESULT;
  sendOverSockets(buffer, sizeof(buffer));
  receiveFromSockets(buffer, sizeof(buffer));
  return 0;
}

int SmallMGC_Api::receiveFromSockets(char* buffer, int len)
{
   socklen_t smallmgcSocketLen = sizeof(struct sockaddr);
   struct sockaddr_un recvSocket;
   int n = 0;
   n=recvfrom(m_orig_sock, buffer, len, 0,
            (struct sockaddr *) &recvSocket, &smallmgcSocketLen);
   if (n < 0)
   {
     if  (errno == EWOULDBLOCK)
     {
       // normal case there is no message
     }
     else
     {
       printf("an error: %s\n", strerror(errno));
     }
   }
   else
   {
     switch (((int*)buffer)[0])
     {

     }
   }
   return n;
}
int SmallMGC_Api::sendRawMessage(char* destination, char* message)
{
  char buffer[2000];
  SmallMGC_Api_Commands* command = (SmallMGC_Api_Commands*)buffer;
  *command = SmallMGC_API_SEND_RAW;
  unsigned int ipLength = strlen(destination);
  memcpy(buffer+4, &ipLength,4);
  memcpy(buffer+8,(char*)destination, strlen(destination));
  memcpy(buffer+8+strlen(destination), (char*)message, strlen(message));
  sendOverSockets(buffer, sizeof(buffer));
  return 0;
}

int SmallMGC_Api::getReceivedMessage(SmallMGC_Api_Commands* command, int* transactionId, int* contextId,
		                 int* eventId, char* termId, char* event, char* localSdp, char* remoteSdp)
{
  char buffer[2000];
  int n = receiveFromSockets(buffer, sizeof(buffer));
  if (n > 0)
  {
	SmallMGC_Api_TestReceivedMessage* message = (SmallMGC_Api_TestReceivedMessage*)buffer;
	*command = message->command;
	*transactionId = message->transactionId;
	*contextId = message->contextId;
	*eventId = message->eventId;
	memcpy(termId, message->termId, 32);
	memcpy(event, message->event, 128);
	memcpy(localSdp, message->localSdp, 512);
	memcpy(remoteSdp, message->remoteSdp, 512);
	return 0;
  }
  return 1;
}



void SmallMGC_Api::sendOverSockets(char* buffer, int len)
{
  int n = sendto( m_orig_sock, buffer, len, 0, (struct sockaddr *) &m_smallmgcSocket, sizeof(struct sockaddr) );
  if (n != len)
  {
	  printf("an error: %s\n", strerror(errno));
	  return;
  }
}

void SmallMGC_Api::createUnixSockets()
{
  //static char     apiUser_buf[2000],    // Message from client
  //               pipe_buf[2000];    // Output from fortune command
  int flag = 1;
  if ((m_orig_sock = socket(PF_UNIX, SOCK_DGRAM, 0)) < 0) {
   	//Application::instance().logger().information("error creating socket ");
    return;
  }

  // make socket non blocking
  //if (ioctl(m_orig_sock, FIONBIO, &flag) < 0 )
  //{
	//Application::instance().logger().information("error ioctl");
	//return;
  //}


  m_apiUserSocket.sun_family = AF_UNIX;
  strcpy(m_apiUserSocket.sun_path, SmallMGC_Api::SMALLMGC_API_USER);

  unlink( SmallMGC_Api::SMALLMGC_API_USER);                // Remove old copy if present
  // BIND the address
  if (bind(m_orig_sock, (struct sockaddr *) &m_apiUserSocket,
        sizeof(m_apiUserSocket.sun_family)+strlen(m_apiUserSocket.sun_path)) < 0)
  {
	//Application::instance().logger().information("error bind");
    close( m_orig_sock );                         // Close socket
    unlink( SmallMGC_Api::SMALLMGC_API_USER);  // Remove it
    return;
  }

  m_smallmgcSocket.sun_family = AF_UNIX;
  strcpy(m_smallmgcSocket.sun_path, SmallMGC_Api::SMALLMGC_API_SOCKET);


}

char SmallMGC_Api::SMALLMGC_API_SOCKET[] ="/tmp/smapis";
char SmallMGC_Api::SMALLMGC_API_USER[]   ="/tmp/smapiu";

//char SmallMGC_Api::SMALLMGC_API_SOCKET[] ="/home/thomas/smallmgc_api_socket";
//char SmallMGC_Api::SMALLMGC_API_USER[]   ="/home/thomas/smallmgc_api_user";
